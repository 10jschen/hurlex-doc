% -*- coding: UTF-8 -*-
% hurlex-chapt4.tex
% hurlex 开发文档 第4章内容

\section {字符模式下的显卡驱动}

\par 本章开始，我们将开始描述对屏幕输出的控制了。在第二章我们简单谈过地址空间的事情，我们提到4G的地址空间并非全部指向\allowbreak
主存储器，而是有部分的地址分给了其他外设。特别地，在地址空间的最低1MB处，有很多地址是属于外部设备的，下图描绘了该处地址\allowbreak
映射的分布情况：



\par 首先是几个端口读写函数的实现。我们之前介绍过端口地址的概念，有的外设的相关存储单元在端口地址里，需要CPU通过特殊的in/out\allowbreak
指令才可以访问到。但是C语言并没有直接操作端口的方法，而且频繁的内联汇编麻烦又容易出错。所以我们索性定义几个端口读写函数。\allowbreak
代码如下：

\begin{lstlisting}[language = C, label = libs/common.c, caption = libs/common.c]
#include "common.h"

// 端口写一个字节
inline void outb(uint16_t port, uint8_t value)
{
	asm volatile ("outb %1, %0" : : "dN" (port), "a" (value));
}

// 端口读一个字节
inline uint8_t inb(uint16_t port)
{
	uint8_t ret;

	asm volatile("inb %1, %0" : "=a" (ret) : "dN" (port));

	return ret;
}

// 端口读一个字
inline uint16_t inw(uint16_t port)
{
	uint16_t ret;

	asm volatile ("inw %1, %0" : "=a" (ret) : "dN" (port));

	return ret;
}
\end{lstlisting}

\par 对应的头文件如下：
\begin{lstlisting}[language = C, label = include/common.h, caption = include/common.h]
#ifndef INCLUDE_COMMON_H_
#define INCLUDE_COMMON_H_

#include "types.h"

// 端口写一个字节
void outb(uint16_t port, uint8_t value);

// 端口读一个字节
uint8_t inb(uint16_t port);

// 端口读一个字
uint16_t inw(uint16_t port);

#endif // INCLUDE_COMMON_H_
\end{lstlisting}

\par 细心的读者想必已经发现了函数定义之前的inline关键字了吧？这是GNU对ANSI C的扩展，它和C++语言里的inline的作用是一样的。\allowbreak
函数前面加上inline之后，编译器会尝试\footnote{没错，是尝试。内联对编译来说只是一个建议，编译器有权利根据实际情况自由处理。}\allowbreak
在该函数的调用点进行直接进行代码展开，而不是传统的函数调用。这么做的既有传统函数的好处，即避免了重复性的编码，减少了出错的几率。\allowbreak
又减少了函数的调用，提高了代码的执行效率。另外，你可能见过宏函数这种用法，但是宏函数是没有参数类型的检查的，相比inline还是逊了一筹。




%\begin{lstlisting}[language = C, label = libs/common.c, caption = libs/common.c]
%\end{lstlisting}

